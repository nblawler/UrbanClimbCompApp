<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Competitor {{ competitor.id }} Â· Urban Climb Comp</title>
		<link rel="stylesheet" href="/static/app.css" />
	</head>
	<body>
		<nav class="container" style="display:flex; gap:12px; align-items:center; margin-top:16px;">
			<a class="back" href="/">Home</a>
			<a class="back" href="/leaderboard">Leaderboard</a>
		</nav>

		<main class="container">
			<header class="header">
				<h1>Competitor #{{ competitor.id }}</h1>
				<h2 style="margin-top:4px; color:var(--accent);">
					Total Points: <span id="total-points">{{ total_points }}</span>
				</h2>
				<a class="back" href="/">Switch competitor</a>
			</header>

			<section class="grid">
				{% for n in climbs %}
				{% set s = existing.get(n) %}
				<div class="climb-card" data-climb="{{ n }}">
					<h2>Climb {{ n }}</h2>

					<div class="row">
						<label>Attempts</label>
						<input
							type="number"
							min="1"
							max="50"
							value="{{ s.attempts if s else 1 }}"
							class="attempts"
						/>
					</div>

					<div class="row">
						<label class="check">
							<input
								type="checkbox"
								class="topped"
								{% if s and s.topped %}checked{% endif %}
							/>
							Topped
						</label>
					</div>

					<button class="save">Save</button>
					<div class="status" aria-live="polite"></div>
				</div>
				{% endfor %}
			</section>

			<section class="summary">
				<h3>Summary</h3>
				<ul id="summary-list"></ul>
			</section>
		</main>

		<script>
			const competitorId = {{ competitor.id }};
			const cards = document.querySelectorAll(".climb-card");

			function showStatus(el, msg, ok = true) {
				el.textContent = msg;
				el.className = "status " + (ok ? "ok" : "err");
				setTimeout(() => {
					el.textContent = "";
					el.className = "status";
				}, 1500);
			}

			function clampAttempts(inputEl){
				let n = parseInt(inputEl.value, 10);
				if (isNaN(n) || n < 1) { n = 1; }
				if (n > 50) { n = 50; }
				inputEl.value = n; // reflect clamped value in UI
				return n;
			}

			async function updateTotals() {
				try {
					const res = await fetch(`/api/competitor/${competitorId}/totals?t=${Date.now()}`, { cache: 'no-store' });
					if (!res.ok) return;
					const t = await res.json();
					const el = document.getElementById("total-points");
					if (el) el.textContent = t.total_points;
				} catch (e) {
					/* silent */
				}
			}

			async function save(card) {
				const climb = parseInt(card.dataset.climb, 10);
				const attemptsInput = card.querySelector(".attempts");
				const attempts = clampAttempts(attemptsInput); // enforce 1..50
				const topped = card.querySelector(".topped").checked;
				const status = card.querySelector(".status");

				try {
					const res = await fetch("/api/score?t=" + Date.now(), {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({
							competitor_id: competitorId,
							climb_number: climb,
							attempts,
							topped,
						}),
						cache: 'no-store'
					});

					if (!res.ok) {
						const t = await res.text();
						showStatus(status, "Error: " + t, false);
						return;
					}

					await res.json();
					showStatus(status, "Saved");
					refreshSummary();
					updateTotals(); // live-update total points
				} catch (e) {
					showStatus(status, "Network error", false);
				}
			}

			async function refreshSummary() {
				try {
					const res = await fetch(`/api/score/${competitorId}?t=${Date.now()}`, { cache: 'no-store' });
					const rows = await res.json();
					const ul = document.getElementById("summary-list");
					ul.innerHTML = "";
					rows.forEach((r) => {
						const li = document.createElement("li");
						li.textContent = `Climb ${r.climb_number}: attempts ${r.attempts}, ${r.topped ? "TOP" : "no top"}`;
						ul.appendChild(li);
					});
					updateTotals(); // also refresh total when summary reloads
				} catch (e) {
					/* silent */
				}
			}

			// Prevent 0 by clamping on blur/change as well
			cards.forEach((card) => {
				const input = card.querySelector(".attempts");
				input.addEventListener("blur", () => { clampAttempts(input); });
				input.addEventListener("change", () => { clampAttempts(input); });
				card.querySelector(".save").addEventListener("click", () => save(card));
			});

			refreshSummary(); // initial load populates summary + totals
		</script>
	</body>
</html>